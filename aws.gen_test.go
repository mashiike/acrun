// Code generated by cmd/codegen. DO NOT EDIT.

package acrun

import (
	"testing"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/bedrockagentcorecontrol/types"
	"github.com/stretchr/testify/require"
)

func TestConvertAgentRuntimeArtifact_Generated(t *testing.T) {
	cases := []struct {
		Name      string
		Input     any
		Expected  types.AgentRuntimeArtifact
		ShouldErr bool
	}{
		{
			Name:      "codeConfiguration",
			Input:     map[string]any{"codeConfiguration": map[string]any{"code": nil, "entryPoint": []any{"test_value", "test_value"}, "runtime": "test_value"}},
			Expected:  &types.AgentRuntimeArtifactMemberCodeConfiguration{Value: types.CodeConfiguration{Code: nil, EntryPoint: []string{"test_value", "test_value"}, Runtime: types.AgentManagedRuntimeType("test_value")}},
			ShouldErr: false,
		},
		{
			Name:      "containerConfiguration",
			Input:     map[string]any{"containerConfiguration": map[string]any{"containerUri": "test_value"}},
			Expected:  &types.AgentRuntimeArtifactMemberContainerConfiguration{Value: types.ContainerConfiguration{ContainerUri: aws.String("test_value")}},
			ShouldErr: false,
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			// Test convertToAgentRuntimeArtifact
			got, err := convertToAgentRuntimeArtifact(tc.Input, true)
			if tc.ShouldErr {
				require.Error(t, err)
				return
			}
			require.NoError(t, err)
			require.EqualValues(t, tc.Expected, got)

			// Test round-trip through convertFromAgentRuntimeArtifact
			converted, err := convertFromAgentRuntimeArtifact(got)
			require.NoError(t, err)

			// Convert back again
			roundTrip, err := convertToAgentRuntimeArtifact(converted, true)
			require.NoError(t, err)
			require.EqualValues(t, tc.Expected, roundTrip)
		})
	}
}

func TestMarshalUnmarshalAgentRuntime_AgentRuntimeArtifact_Generated(t *testing.T) {
	cases := []struct {
		Name    string
		Runtime *AgentRuntime
	}{
		{
			Name: "with_codeConfiguration",
			Runtime: &AgentRuntime{
				AgentRuntimeName:     aws.String("test_runtime"),
				RoleArn:              aws.String("arn:aws:iam::123456789012:role/TestRole"),
				AgentRuntimeArtifact: &types.AgentRuntimeArtifactMemberCodeConfiguration{Value: types.CodeConfiguration{Code: nil, EntryPoint: []string{"test_value", "test_value"}, Runtime: types.AgentManagedRuntimeType("test_value")}},
			},
		},
		{
			Name: "with_containerConfiguration",
			Runtime: &AgentRuntime{
				AgentRuntimeName:     aws.String("test_runtime"),
				RoleArn:              aws.String("arn:aws:iam::123456789012:role/TestRole"),
				AgentRuntimeArtifact: &types.AgentRuntimeArtifactMemberContainerConfiguration{Value: types.ContainerConfiguration{ContainerUri: aws.String("test_value")}},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			// Test marshal
			bs, err := marshalAgentRuntime(tc.Runtime, "  ")
			require.NoError(t, err)
			require.NotEmpty(t, bs)

			// Test unmarshal
			got, err := unmarshalAgentRuntime(bs, true)
			require.NoError(t, err)
			require.EqualValues(t, tc.Runtime.AgentRuntimeArtifact, got.AgentRuntimeArtifact)
		})
	}
}

func TestConvertAuthorizerConfiguration_Generated(t *testing.T) {
	cases := []struct {
		Name      string
		Input     any
		Expected  types.AuthorizerConfiguration
		ShouldErr bool
	}{
		{
			Name:      "customJWTAuthorizer",
			Input:     map[string]any{"customJWTAuthorizer": map[string]any{"discoveryUrl": "test_value", "allowedAudience": []any{"test_value", "test_value"}, "allowedClients": []any{"test_value", "test_value"}, "allowedScopes": []any{"test_value", "test_value"}, "customClaims": []any{nil, nil}}},
			Expected:  &types.AuthorizerConfigurationMemberCustomJWTAuthorizer{Value: types.CustomJWTAuthorizerConfiguration{DiscoveryUrl: aws.String("test_value"), AllowedAudience: []string{"test_value", "test_value"}, AllowedClients: []string{"test_value", "test_value"}, AllowedScopes: []string{"test_value", "test_value"}, CustomClaims: []types.CustomClaimValidationType{types.CustomClaimValidationType{}, types.CustomClaimValidationType{}}}},
			ShouldErr: false,
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			// Test convertToAuthorizerConfiguration
			got, err := convertToAuthorizerConfiguration(tc.Input, true)
			if tc.ShouldErr {
				require.Error(t, err)
				return
			}
			require.NoError(t, err)
			require.EqualValues(t, tc.Expected, got)

			// Test round-trip through convertFromAuthorizerConfiguration
			converted, err := convertFromAuthorizerConfiguration(got)
			require.NoError(t, err)

			// Convert back again
			roundTrip, err := convertToAuthorizerConfiguration(converted, true)
			require.NoError(t, err)
			require.EqualValues(t, tc.Expected, roundTrip)
		})
	}
}

func TestMarshalUnmarshalAgentRuntime_AuthorizerConfiguration_Generated(t *testing.T) {
	cases := []struct {
		Name    string
		Runtime *AgentRuntime
	}{
		{
			Name: "with_customJWTAuthorizer",
			Runtime: &AgentRuntime{
				AgentRuntimeName:        aws.String("test_runtime"),
				RoleArn:                 aws.String("arn:aws:iam::123456789012:role/TestRole"),
				AuthorizerConfiguration: &types.AuthorizerConfigurationMemberCustomJWTAuthorizer{Value: types.CustomJWTAuthorizerConfiguration{DiscoveryUrl: aws.String("test_value"), AllowedAudience: []string{"test_value", "test_value"}, AllowedClients: []string{"test_value", "test_value"}, AllowedScopes: []string{"test_value", "test_value"}, CustomClaims: []types.CustomClaimValidationType{types.CustomClaimValidationType{}, types.CustomClaimValidationType{}}}},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			// Test marshal
			bs, err := marshalAgentRuntime(tc.Runtime, "  ")
			require.NoError(t, err)
			require.NotEmpty(t, bs)

			// Test unmarshal
			got, err := unmarshalAgentRuntime(bs, true)
			require.NoError(t, err)
			require.EqualValues(t, tc.Runtime.AuthorizerConfiguration, got.AuthorizerConfiguration)
		})
	}
}

func TestConvertRequestHeaderConfiguration_Generated(t *testing.T) {
	cases := []struct {
		Name      string
		Input     any
		Expected  types.RequestHeaderConfiguration
		ShouldErr bool
	}{
		{
			Name:      "allowList",
			Input:     map[string]any{"allowList": []any{"test_value", "test_value"}},
			Expected:  &types.RequestHeaderConfigurationMemberRequestHeaderAllowlist{Value: []string{"test_value", "test_value"}},
			ShouldErr: false,
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			// Test convertToRequestHeaderConfiguration
			got, err := convertToRequestHeaderConfiguration(tc.Input, true)
			if tc.ShouldErr {
				require.Error(t, err)
				return
			}
			require.NoError(t, err)
			require.EqualValues(t, tc.Expected, got)

			// Test round-trip through convertFromRequestHeaderConfiguration
			converted, err := convertFromRequestHeaderConfiguration(got)
			require.NoError(t, err)

			// Convert back again
			roundTrip, err := convertToRequestHeaderConfiguration(converted, true)
			require.NoError(t, err)
			require.EqualValues(t, tc.Expected, roundTrip)
		})
	}
}

func TestMarshalUnmarshalAgentRuntime_RequestHeaderConfiguration_Generated(t *testing.T) {
	cases := []struct {
		Name    string
		Runtime *AgentRuntime
	}{
		{
			Name: "with_allowList",
			Runtime: &AgentRuntime{
				AgentRuntimeName:           aws.String("test_runtime"),
				RoleArn:                    aws.String("arn:aws:iam::123456789012:role/TestRole"),
				RequestHeaderConfiguration: &types.RequestHeaderConfigurationMemberRequestHeaderAllowlist{Value: []string{"test_value", "test_value"}},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			// Test marshal
			bs, err := marshalAgentRuntime(tc.Runtime, "  ")
			require.NoError(t, err)
			require.NotEmpty(t, bs)

			// Test unmarshal
			got, err := unmarshalAgentRuntime(bs, true)
			require.NoError(t, err)
			require.EqualValues(t, tc.Runtime.RequestHeaderConfiguration, got.RequestHeaderConfiguration)
		})
	}
}
