// Code generated by cmd/codegen. DO NOT EDIT.

package acrun

import (
	"bytes"
	"encoding/json"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/service/bedrockagentcorecontrol"
	"github.com/aws/aws-sdk-go-v2/service/bedrockagentcorecontrol/types"
)

// convertToAgentRuntimeArtifact converts any value to types.AgentRuntimeArtifact
func convertToAgentRuntimeArtifact(v any, strict bool) (types.AgentRuntimeArtifact, error) {
	data, err := json.Marshal(v)
	if err != nil {
		return nil, err
	}

	// Try codeConfiguration variant
	{
		dec := json.NewDecoder(bytes.NewReader(data))
		if strict {
			dec.DisallowUnknownFields()
		}
		var codeConfigurationVariant struct {
			Field types.CodeConfiguration `json:"codeConfiguration"`
		}
		if err := dec.Decode(&codeConfigurationVariant); err == nil {
			return &types.AgentRuntimeArtifactMemberCodeConfiguration{
				Value: codeConfigurationVariant.Field,
			}, nil
		}
	}

	// Try containerConfiguration variant
	{
		dec := json.NewDecoder(bytes.NewReader(data))
		if strict {
			dec.DisallowUnknownFields()
		}
		var containerConfigurationVariant struct {
			Field types.ContainerConfiguration `json:"containerConfiguration"`
		}
		if err := dec.Decode(&containerConfigurationVariant); err == nil && containerConfigurationVariant.Field.ContainerUri != nil {
			return &types.AgentRuntimeArtifactMemberContainerConfiguration{
				Value: containerConfigurationVariant.Field,
			}, nil
		}
	}

	return nil, fmt.Errorf("no valid variant found for AgentRuntimeArtifact")
}

// convertFromAgentRuntimeArtifact converts types.AgentRuntimeArtifact to map[string]any
func convertFromAgentRuntimeArtifact(v types.AgentRuntimeArtifact) (any, error) {
	if v == nil {
		return nil, nil
	}
	switch v := v.(type) {
	case *types.AgentRuntimeArtifactMemberCodeConfiguration:
		bs, err := marshalJSON(v.Value)
		if err != nil {
			return nil, err
		}
		return map[string]any{
			"codeConfiguration": json.RawMessage(bs),
		}, nil
	case *types.AgentRuntimeArtifactMemberContainerConfiguration:
		bs, err := marshalJSON(v.Value)
		if err != nil {
			return nil, err
		}
		return map[string]any{
			"containerConfiguration": json.RawMessage(bs),
		}, nil
	default:
		return nil, fmt.Errorf("unknown AgentRuntimeArtifact type: %T", v)
	}
}

// convertToAuthorizerConfiguration converts any value to types.AuthorizerConfiguration
func convertToAuthorizerConfiguration(v any, strict bool) (types.AuthorizerConfiguration, error) {
	data, err := json.Marshal(v)
	if err != nil {
		return nil, err
	}

	// Try customJWTAuthorizer variant
	{
		dec := json.NewDecoder(bytes.NewReader(data))
		if strict {
			dec.DisallowUnknownFields()
		}
		var customJWTAuthorizerVariant struct {
			Field types.CustomJWTAuthorizerConfiguration `json:"customJWTAuthorizer"`
		}
		if err := dec.Decode(&customJWTAuthorizerVariant); err == nil && customJWTAuthorizerVariant.Field.DiscoveryUrl != nil {
			return &types.AuthorizerConfigurationMemberCustomJWTAuthorizer{
				Value: customJWTAuthorizerVariant.Field,
			}, nil
		}
	}

	return nil, fmt.Errorf("no valid variant found for AuthorizerConfiguration")
}

// convertFromAuthorizerConfiguration converts types.AuthorizerConfiguration to map[string]any
func convertFromAuthorizerConfiguration(v types.AuthorizerConfiguration) (any, error) {
	if v == nil {
		return nil, nil
	}
	switch v := v.(type) {
	case *types.AuthorizerConfigurationMemberCustomJWTAuthorizer:
		bs, err := marshalJSON(v.Value)
		if err != nil {
			return nil, err
		}
		return map[string]any{
			"customJWTAuthorizer": json.RawMessage(bs),
		}, nil
	default:
		return nil, fmt.Errorf("unknown AuthorizerConfiguration type: %T", v)
	}
}

// convertToRequestHeaderConfiguration converts any value to types.RequestHeaderConfiguration
func convertToRequestHeaderConfiguration(v any, strict bool) (types.RequestHeaderConfiguration, error) {
	data, err := json.Marshal(v)
	if err != nil {
		return nil, err
	}

	// Try allowList variant
	{
		dec := json.NewDecoder(bytes.NewReader(data))
		if strict {
			dec.DisallowUnknownFields()
		}
		var allowListVariant struct {
			AllowList []string `json:"allowList"`
		}
		if err := dec.Decode(&allowListVariant); err == nil {
			return &types.RequestHeaderConfigurationMemberRequestHeaderAllowlist{
				Value: allowListVariant.AllowList,
			}, nil
		}
	}

	return nil, fmt.Errorf("no valid variant found for RequestHeaderConfiguration")
}

// convertFromRequestHeaderConfiguration converts types.RequestHeaderConfiguration to map[string]any
func convertFromRequestHeaderConfiguration(v types.RequestHeaderConfiguration) (any, error) {
	if v == nil {
		return nil, nil
	}
	switch v := v.(type) {
	case *types.RequestHeaderConfigurationMemberRequestHeaderAllowlist:
		return map[string]any{
			"allowList": v.Value,
		}, nil
	default:
		return nil, fmt.Errorf("unknown RequestHeaderConfiguration type: %T", v)
	}
}

func newAgentRuntimeFromResponse(out *bedrockagentcorecontrol.GetAgentRuntimeOutput) (*AgentRuntime, error) {
	bs, err := marshalJSON(out, func(opts *marshalJSONOptions) {
		opts.hooks = append(opts.hooks, func(path, key string, value any) (string, any, error) {
			if matchJSONKey(path, "$.agentRuntimeArtifact") {
				v, err := convertFromAgentRuntimeArtifact(out.AgentRuntimeArtifact)
				if err != nil {
					return "", nil, err
				}
				return key, v, nil
			}
			if matchJSONKey(path, "$.authorizerConfiguration") {
				v, err := convertFromAuthorizerConfiguration(out.AuthorizerConfiguration)
				if err != nil {
					return "", nil, err
				}
				return key, v, nil
			}
			if matchJSONKey(path, "$.requestHeaderConfiguration") {
				v, err := convertFromRequestHeaderConfiguration(out.RequestHeaderConfiguration)
				if err != nil {
					return "", nil, err
				}
				return key, v, nil
			}
			return key, value, nil
		})
		opts.ignoreLowerCamelPaths = append(opts.ignoreLowerCamelPaths,
			"$.environmentVariables.*",
		)
	})
	if err != nil {
		return nil, err
	}
	def, err := unmarshalAgentRuntime(bs, false)
	if err != nil {
		return nil, err
	}
	return def, nil
}

func newUpdateAgentRuntimeInput(out *bedrockagentcorecontrol.GetAgentRuntimeOutput, def *AgentRuntime) (*bedrockagentcorecontrol.UpdateAgentRuntimeInput, error) {
	var input bedrockagentcorecontrol.UpdateAgentRuntimeInput
	unmarshalOpts := func(opts *unmarshalJSONOptions) {
		opts.strict = false
		opts.hooks = append(opts.hooks, func(path, key string, value any) (string, any, error) {
			if matchJSONKey(path, "$.agentRuntimeArtifact") {
				v, err := convertToAgentRuntimeArtifact(value, false)
				if err != nil {
					return "", nil, err
				}
				input.AgentRuntimeArtifact = v
				return key, nil, nil
			}
			if matchJSONKey(path, "$.authorizerConfiguration") {
				v, err := convertToAuthorizerConfiguration(value, false)
				if err != nil {
					return "", nil, err
				}
				input.AuthorizerConfiguration = v
				return key, nil, nil
			}
			if matchJSONKey(path, "$.requestHeaderConfiguration") {
				v, err := convertToRequestHeaderConfiguration(value, false)
				if err != nil {
					return "", nil, err
				}
				input.RequestHeaderConfiguration = v
				return key, nil, nil
			}
			return key, value, nil
		})
		opts.ignoreUpperCamelPaths = append(opts.ignoreUpperCamelPaths,
			"$.environmentVariables.*",
		)
	}
	// Override with the definition file
	bs, err := marshalAgentRuntime(def, "")
	if err != nil {
		return nil, err
	}
	if err := unmarshalJSON(bs, &input, unmarshalOpts); err != nil {
		return nil, err
	}
	input.AgentRuntimeId = out.AgentRuntimeId
	return &input, nil
}

func unmarshalAgentRuntime(bs []byte, strict bool) (*AgentRuntime, error) {
	var def AgentRuntime
	hook := func(path, key string, value any) (string, any, error) {
		if matchJSONKey(path, "$.agentRuntimeArtifact") {
			v, err := convertToAgentRuntimeArtifact(value, strict)
			if err != nil {
				return "", nil, err
			}
			def.AgentRuntimeArtifact = v
			return key, nil, nil
		}
		if matchJSONKey(path, "$.authorizerConfiguration") {
			v, err := convertToAuthorizerConfiguration(value, strict)
			if err != nil {
				return "", nil, err
			}
			def.AuthorizerConfiguration = v
			return key, nil, nil
		}
		if matchJSONKey(path, "$.requestHeaderConfiguration") {
			v, err := convertToRequestHeaderConfiguration(value, strict)
			if err != nil {
				return "", nil, err
			}
			def.RequestHeaderConfiguration = v
			return key, nil, nil
		}
		return key, value, nil
	}
	if err := unmarshalJSON(bs, &def, func(opts *unmarshalJSONOptions) {
		opts.hooks = append(opts.hooks, hook)
		opts.strict = strict
		opts.ignoreUpperCamelPaths = append(opts.ignoreUpperCamelPaths,
			"$.environmentVariables.*",
		)
	}); err != nil {
		return nil, err
	}
	return &def, nil
}

func marshalAgentRuntime(v *AgentRuntime, indent string) ([]byte, error) {
	bs, err := marshalJSON(v, func(opts *marshalJSONOptions) {
		opts.hooks = append(opts.hooks, func(path, key string, value any) (string, any, error) {
			if matchJSONKey(path, "$.agentRuntimeArtifact") {
				v, err := convertFromAgentRuntimeArtifact(v.AgentRuntimeArtifact)
				if err != nil {
					return "", nil, err
				}
				return key, v, nil
			}
			if matchJSONKey(path, "$.authorizerConfiguration") {
				v, err := convertFromAuthorizerConfiguration(v.AuthorizerConfiguration)
				if err != nil {
					return "", nil, err
				}
				return key, v, nil
			}
			if matchJSONKey(path, "$.requestHeaderConfiguration") {
				v, err := convertFromRequestHeaderConfiguration(v.RequestHeaderConfiguration)
				if err != nil {
					return "", nil, err
				}
				return key, v, nil
			}
			return key, value, nil
		})
		opts.ignoreLowerCamelPaths = append(opts.ignoreLowerCamelPaths,
			"$.environmentVariables.*",
		)
	})
	if err != nil {
		return nil, err
	}
	if indent == "" {
		return bs, nil
	}
	var buf bytes.Buffer
	if err := json.Indent(&buf, bs, "", indent); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
